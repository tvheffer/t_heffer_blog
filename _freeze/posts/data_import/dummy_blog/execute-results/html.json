{
  "hash": "e0aee63ff02cdb0de5cbcf87cb6d6402",
  "result": {
    "markdown": "---\ntitle: 'Preparing data in R'\ndate: '2023-06-30'\ncategories: ['R', 'Data Wrangling']\nexecute: \n  message: false\n  warning: false\neditor_options: \n  chunk_output_type: console\ntoc: true\n---\n\n\nThis post covers how to read in data, change data types, and index variables in a dataframe\n\n## Read in data to R\n\n**CSV File:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsat_dat <- read.csv(\"1_raw_data/workshop_data.csv\", header = TRUE)\n```\n:::\n\n\n**SPSS File:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(haven) \ndata_spss <- read_sav(\"1_raw_data/workshop_data.sav\")\n```\n:::\n\n\n**Excel File:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readxl)\ndata_xl <- read_xlsx(\"1_raw_data/workshop_data.xlsx\")\n```\n:::\n\n\n**R data:**\n\n.Rdata files store the structure of your variables. Once you finish with data wrangling, it is useful to save your dataset to an .Rdata file so that it maintains any edits (e.g., class of factor, re-leveling etc). Downside: you can only open it in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsave(data, file = \"name_of_file.Rdata\")\nload(\"name_of_file.Rdata\") \n```\n:::\n\n\nWhen you load this dataset back into r, it will be titled `data` in the environment \n\n## Data types\n\n[Good Overview](https://swcarpentry.github.io/r-novice-inflammation/13-supp-data-structures)\\\n**Data frame**: rows are the unit of observations, columns are the variables.\\\n**Integer:** `as.integer(44.1)` provides rounded values (44)\\\n**Numeric:** `as.numeric(44.1)` saves decimals (44.1)\\\n**Matrix:** can only store data that is all the same type\\\n**Characters:** string- can use single or double quotes\\\n**Factor:** used to classify categorical data\n\n## Inspect data types\n\nAfter you import data, it is necessary to check the structure of the data. <br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(sat_dat)\n\nlibrary(dplyr)\nglimpse(sat_dat)\n\nclass(sat_dat$variable_name)\n```\n:::\n\n\n## Convert data types\nIf you have a categorical variable that is classified as numeric, it is **necessary** you change this to a factor. If you leave it as numeric, R will assume it is a continuous variable. In other words, that category one is 1 unit smaller than category two, which of course is nonsense for nominal data. This is a critical step and will save you issues with plotting and analyses down the road!\n\n**Nominal variables** (Factors): categories with no particular order (sex, gender, hair color, etc.) <br />\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata$sex <- factor(data$sex, labels = c(\"males\", \"females\"))\n```\n:::\n\n\n**Ordinal variables:** categories with order relations (grades, social status, etc.) <br />\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata$education <- ordered(data$education)\n```\n:::\n\n\n-   Likert items (e.g. ranging from 1 \"completely disagree\" to 5 \"completely agree\") are sometimes a tricky data type. Technically they are *ordinal* and should be treated as such when they are a **response variable**. It makes our life easier to treat them as *continuous* when they are **predictors**. <br />\n\n**Metric scale level (aka numerical)**: distance relation between the values (income, IQ,SAT, age):<br /> - **Ratio scale**: natural 0 point (income, body height, etc.)<br /> - **Interval scale**: no natural 0 point (temperature Celsius, year, etc.)\n\n## Re-leveling a variable\n\nWhen you create a factor, the baseline category is *alphabetical* order, usually you want the control group as a baseline category. To change the levels, use the following command.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata$group <- relevel(data$group, ref = \"control\")\n```\n:::\n\n\n## Indexing (extracting elements from a dataset)\n\nWhen indexing, the order is: \\[row,column\\] <br /> `dat_data[1,3]` extract the value in row 1, column 3 <br /> `dat_data[5,]` extract all values in row 5 <br />\n\nYou can also index multiple columns using `c()` stands for concatenate (or combine)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec1 <- c(6, 77, 2333, 4, 8)\nvec1[c(2,3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]   77 2333\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}